<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Matthew Kudija | Reading Notes</title>
<link rel="shortcut icon" type="image/jpg" href="https://raw.githubusercontent.com/mkudija/mkudija.github.io/master/favicon.ico"/>
<meta name="description" content="Matthew Kudija's reading notes.">
<meta name="keywords" content="matthew, kudija, mkudija, catholic, reading, books">
<link rel="shortcut icon" href="https://github.com/mkudija/mkudija.github.io/blob/master/favicon.ico">
<link rel="next" href="https://matthewkudija.com/reading.html">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<link rel="stylesheet" href="../assets/css/reading-notes.css" />
<link rel="stylesheet" href="../assets/css/bigfoot-default.css" />
</head>
<body>

<!-- Wrapper -->
<div id="wrapper">

<!-- Main -->
<div id="main">
<div class="inner">
<!-- Header -->
<header id="header">
<span style="color:#777;">
Matthew <strong>Kudija</strong>'s <a href="https://matthewkudija.com/notes/">Notes</a> | <a href="https://matthewkudija.com/">Home</a>
</span>
</header>
<hr>

<!-- Content -->
<section>

<h1 id="sql-general-how-to">SQL General How-To</h1>

<h2 id="find-tables-with-colname-column">Find tables with <code>colName</code> column</h2>

<p><code>SQL
select t.table_schema,
       t.table_name
from information_schema.tables t
inner join information_schema.columns c 
           on c.table_name = t.table_name 
           and c.table_schema = t.table_schema
where c.column_name = 'colName'
      and t.table_schema not in ('information_schema', 'pg_catalog')
      and t.table_type = 'BASE TABLE'
order by t.table_schema;
</code></p>

<h2 id="unique-items-in-column">Unique items in <strong><code>column</code></strong></h2>

<p><code>SQL
SELECT 
    t.device
FROM 
    database.table t
GROUP BY t.device
</code></p>

<table>
<thead>
<tr>
  <th></th>
  <th>device</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1</td>
  <td>"iPhone10,1"</td>
</tr>
<tr>
  <td>2</td>
  <td>"iPhone10,2"</td>
</tr>
<tr>
  <td>3</td>
  <td>"iPhone10,3"</td>
</tr>
<tr>
  <td>4</td>
  <td>"iPhone10,4"</td>
</tr>
<tr>
  <td>5</td>
  <td>"iPhone10,5"</td>
</tr>
</tbody>
</table>

<h2 id="value_count-of-column">value_count of <strong><code>column</code></strong></h2>

<p><code>SQL
SELECT 
    value_count_col
    ,COUNT(id_col) AS value_count
FROM 
    database.table t
GROUP BY 1
ORDER BY 2 DESC
</code></p>

<p><code>SQL
SELECT 
    t.device
    ,COUNT(t.distance) AS value_count
FROM 
    database.table t
GROUP BY t.device
ORDER BY value_count DESC
</code></p>

<table>
<thead>
<tr>
  <th></th>
  <th>device</th>
  <th>value_count</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1</td>
  <td>iPhone10,5</td>
  <td>23832</td>
</tr>
<tr>
  <td>2</td>
  <td>iPhone10,2</td>
  <td>14553</td>
</tr>
<tr>
  <td>3</td>
  <td>iPhone10,4</td>
  <td>3487</td>
</tr>
<tr>
  <td>4</td>
  <td>iPhone10,3</td>
  <td>3078</td>
</tr>
<tr>
  <td>5</td>
  <td>iPhone10,1</td>
  <td>23</td>
</tr>
</tbody>
</table>

<h2 id="npwhere-equivalent-for-cases"><code>np.where</code> equivalent for cases</h2>

<p><code>SQL
CASE
    WHEN t.score BETWEEN 0  AND 24  THEN '0-24'
    WHEN t.score BETWEEN 25 AND 49  THEN '25-49'
    WHEN t.score BETWEEN 50 AND 74  THEN '50-74'
    WHEN t.score BETWEEN 75 AND 100 THEN '75-100'
    ELSE 'OTHER'
END AS score_group
</code></p>

<h2 id="select-only-firstlast-record-using-rank-over-partition-by">Select only first/last record using <code>RANK() OVER PARTITION BY</code></h2>

<p>In this example, there may be many records for a given <code>user_id</code>, but we only want to select the most recent record for each <code>user_id</code>. Alternatively, we could select the first record by using <code>ASC</code>:</p>

<p><code>SQL
SELECT
    ...
    ...
    FROM(
    SELECT
        ...
    ...
        ,RANK() OVER (PARTITION BY t.user_id ORDER BY t.created_at DESC) AS RANK
        FROM
            database.table AS t
    )
WHERE RANK = 1
</code></p>

<h2 id="round">Round</h2>

<p><code>ROUND</code> rounds the number, and if you don't want the additional <code>.000</code> you can <code>CAST</code> as an integer:</p>

<p><code>CAST(ROUND(col_name, 0) AS INT) AS col_name_rounded</code></p>

<h2 id="decile">Decile</h2>

<p>Try the <code>NTILE</code> function (<a target="_blank" href="https://www.geeksforgeeks.org/ntile-function-in-sql-server/">link</a>).</p>

<p>To get actual deciles you can use a <code>CASE</code> statement:<br />
<code>SQL
SELECT 
    score_decile, 
    COUNT(score_decile) AS count
FROM (
    SELECT
        *,
        CASE
            WHEN score &lt; 10 THEN '0-9'
            WHEN score &gt; 9 AND score &lt; 20 THEN '10-19'
            WHEN score &gt; 19 AND score &lt; 30 THEN '20-29'
            WHEN score &gt; 29 AND score &lt; 40 THEN '30-39'
            WHEN score &gt; 39 AND score &lt; 50 THEN '40-49'
            WHEN score &gt; 49 AND score &lt; 60 THEN '50-59'
            WHEN score &gt; 59 AND score &lt; 70 THEN '60-69'
            WHEN score &gt; 69 AND score &lt; 80 THEN '70-79'
            WHEN score &gt; 79 AND score &lt; 90 THEN '80-89'
            WHEN score &gt; 89 THEN '90-100'
        END as score_decile
    FROM database.table
)
GROUP BY score_decile
ORDER BY score_decile
</code></p>

<p>A quick trick is to <code>ROUND</code> with <code>-1</code> to approximate deciles if score is in the range from 0-100. This is not exact as your buckets will be <code>0-5</code>, <code>6-15</code>...<code>86-95</code>, <code>96-100</code> so the first and last buckets will be small, but if you are just comparing between two distributions and care less about the absolute distribution, this may be an easy trick.</p>

<p><code>SQL
SELECT 
    score_decile_approx, 
    COUNT(score_decile_approx) AS count
FROM (
    SELECT
        *,
        ROUND(score, -1) AS score_decile_approx
    FROM database.table
)
GROUP BY score_decile_approx
ORDER BY score_decile_approx
</code></p>

<p>Finally, we may want the <em>rate</em> rather than the count, which we can get with the <code>RATIO_TO_REPORT(count) OVER () AS rate</code> command. This gives <code>rate</code> for each row as a fraction of the sum of count <code>count</code> column.</p>

<p>```SQL<br />
SELECT<br />
    score<em>decile</em>approx,<br />
    COUNT(score<em>decile</em>approx) AS count,<br />
    RATIO<em>TO</em>REPORT(count) OVER () AS rate<br />
FROM (<br />
    SELECT<br />
        *,<br />
        ROUND(unmapped<em>score, -1) AS score</em>decile_approx<br />
    FROM database.table</p>

<p>)<br />
GROUP BY score<em>decile</em>approx<br />
ORDER BY score<em>decile</em>approx<br />
```</p>

<h2 id="ratio-over-groupby">Ratio over groupby</h2>

<p>Above we use the <code>RATIO_TO_REPORT</code> command to get a ratio rather than count. If we want a time series showing percent, and it is groupe by time (week, month, etc.), this is how you get a rate for each group rather than the whole table:</p>

<p><code>SQL
    RATIO_TO_REPORT(account_count) OVER(PARTITION BY DATE_TRUNC('month', account_timestamp))
</code><br />
or</p>

<p><code>SQL
    DATE_TRUNC('quarter', account_timestamp) AS x,
    RATIO_TO_REPORT(account_count) OVER(PARTITION BY x)
</code></p>

<h2 id="last-7-days-of-data">Last 7 days of data</h2>

<p><code>SQL
SELECT 
    *
FROM 
    database.table t
WHERE
    t.created_at &gt; GETDATE() - INTERVAL '7 days'
</code></p>

<h2 id="date_trunc">DATE_TRUNC</h2>

<p>To transform a timestamp into weekly or daily etc. data use <code>DATE_TRUNC()</code>. Available <code>datepart</code>s are listed <a target="_blank" href="http://www.postgresqltutorial.com/postgresql-date_trunc/">here</a>.</p>

<p><code>SQL
SELECT
    DATE_TRUNC('day', timestamp) AS day
</code><br />
or<br />
<code>SQL
SELECT
    DATE_TRUNC('week', timestamp) AS week
</code><br />
or<br />
<code>SQL
SELECT
    DATE_TRUNC('month', timestamp) AS month
</code><br />
or<br />
<code>SQL
SELECT
    DATE_TRUNC('quarter', timestamp) AS quarter
</code></p>

<h2 id="get-month-offset-from-current-date-also-end-of-month">Get month offset from current date (also end of month)</h2>

<ul>
<li><code>CURRENT_DATE</code> to get current date</li>
<li><code>DATEADD</code> to offset by a number of months</li>
<li><code>LAST_DAY</code> to get last day of month</li>
</ul>

<p><code>SQL
policy_inception_month = LAST_DAY(DATEADD(MM,-6, CURRENT_DATE))
</code></p>

<h2 id="number-of-items-and-most-recent-in-table">Number of items and most recent in table</h2>

<p><code>SQL
SELECT 
    COUNT(*), 
    MAX(created_at) 
FROM 
    database.table
</code></p>

<h2 id="rolling-mean">Rolling Mean</h2>

<p><code>SQL
SELECT 
    DATE_TRUNC('day', profile_timestamp) AS x,
    COUNT(DISTINCT account_id) AS new_user_count,
    AVG(new_user_count) OVER (ORDER BY x ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS count_rolling
FROM 
    database.table
</code></p>

<h2 id="percent-change">Percent Change</h2>

<p>Display the <code>%</code> symbol:</p>

<p><code>SQL
    CONCAT(ROUND((edw_PLE_months_30_4 - edw_PLE_months_30) / edw_PLE_months_30 * 100, 2),'\%') AS percent_diff
</code></p>

<h2 id="percent-of-total">Percent of Total</h2>

<p><code>SQL
earned_premium/SUM(earned_premium) OVER () as percent_of_total
</code></p>

<p>or</p>

<p><code>SQL
RATIO_TO_REPORT(earned_premium) OVER () AS percent_of_total
</code></p>

<h2 id="optimize-query">Optimize Query</h2>

<p>If you run the query with <code>EXPLAIN</code> on top it will give you the query plan and how costly each step is.</p>

<h2 id="most-recent-month-end-date">Most Recent Month-End Date</h2>

<p><code>SQL
SELECT DATEADD(DAY, -1, DATE_TRUNC('month', CURRENT_DATE - 1)) AS most_recent_month_end_date
</code></p>

<h2 id="creatingupdating-tables">Creating/Updating Tables</h2>

<p>Create table:<br />
<code>SQL
-- create table
DROP TABLE IF EXISTS schema.table;
CREATE TABLE schema.table
    AS (
        SELECT * FROM table
    );
</code></p>

<p>Update table:<br />
```SQL<br />
DELETE<br />
FROM table<br />
WHERE source = 'a';</p>

<p>INSERT INTO table<br />
SELECT * FROM source_table<br />
```</p>

<p>Grant usage:<br />
```SQL<br />
GRANT USAGE ON SCHEMA <name> TO user;<br />
GRANT SELECT ON ALL TABLES IN SCHEMA <name TO user;</p>

<p>GRANT USAGE ON SCHEMA <name> TO GROUP readonly;<br />
GRANT SELECT ON ALL TABLES IN SCHEMA <name> TO GROUP readonly;<br />
```</p>

<h2 id="view-tables-in-schema">View Tables in Schema</h2>

<p><code>SQL
-- view tables in schema
SELECT t.table_name
FROM information_schema.tables t
WHERE t.table_schema = 'schema' -- put schema name here
    AND t.table_type = 'BASE TABLE'
ORDER BY t.table_name;
</code></p>

<hr />

<p>Created: 2019-06-25<br />
Updated: 2021-11-17</p>


<br>

</section>
</div>

<div class="div-feedback">
<p>
<em>Please drop me a note to share your thoughts or if you have a correction to make:</em> <code><a href="mailto:m.kudija@gmail.com?subject=Reading%20notes">m.kudija@gmail.com</a></code>
</p>
</div>
</div>
</div>

<!-- Scripts -->
<script src="../assets/js/jquery.min.js"></script>
<script type="text/javascript" src="../assets/js/bigfoot.js"></script>
<script type="text/javascript">
$.bigfoot (
{

}
);
</script>
</body>
<!-- <hr> -->
<footer id="footer" align="center">
<span style="color:#777;">
<center>
<p class="copyright">&copy; 2005<script>new Date().getFullYear()>2005&&document.write("–"+new Date().getFullYear());</script> Matthew Kudija</p>
</center>
</span>
</footer>
<!-- Salve, Regina, Mater misericordiæ
vita, dulcedo, et spes nostra, salve.
Ad te clamamus exsules filii Hevæ
Ad te suspiramus, gementes et flentes
in hac lacrimarum valle.
Eia, ergo, advocata nostra, illos tuos
misericordes oculos ad nos converte;
Et Jesum, benedictum fructum ventris tui
nobis post hoc exsilium ostende.
O clemens, O pia, O dulcis Virgo Maria. -->
</html>
